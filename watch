#!/usr/bin/env bash

# Watch for changes and automatically run `make`. This requires `fswatch` to be
# installed.
#
# Pass -l to enable live reloading.

opts=$*

background_pids=()

add_background_pid() {
    background_pids+=("$1")
}

kill_background_processes() {
    echo "watch -> Cleaning up background process..."
    for pid in "${background_pids[@]}"; do
      kill "$pid" 2>/dev/null
    done
}

trap kill_background_processes EXIT

while getopts ":l" opt
do
    case $opt in
    (l) live_reload=1 ;;
    esac
done

# In order to make live reload more responsive to user actions (i.e. saving
# source files), immediately stop any previously spawned processes and trigger
# another live reload.
cancel_and_run() {
    while read; do
        # kill any previously spawned subprocesses
        if [ ${command_pid:-0} -gt 0 ]; then
            while pkill -P $command_pid 2>/dev/null; do sleep 0.05; done
        fi
        # build and reload
        { \
            make OPTS="${opts} --use-auto-edit-daemon" && \
            echo 'watch -> Requesting reload from Avara...' && \
            python live_reload.py && \
            echo 'watch -> Reload request acknowledged.'
        } &
        local command_pid=$!
    done
}

# [TODO] Use args instead of env vars
DAEMON_MODE=true NO_SIMPLIFY=true node auto-edit.js &
add_background_pid $!

if  [[ live_reload -eq 1 ]]; then
    echo 'watch -> Watching for changes to source files (live reload features enabled)...'
    python dispatcher.py &
    add_background_pid $!
    fswatch -o --no-defer -l 0.1 src alf_globals.py | cancel_and_run
else
    echo 'watch -> Watching for changes to source files...'
    fswatch -o -0 --no-defer -l 0.1 src alf_globals.py | xargs -0 -n1 sh -c "make OPTS='${opts}'"
fi
